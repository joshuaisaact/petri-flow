---
import Layout from "../../layouts/Layout.astro";
import Nav from "../../components/Nav.astro";
import Footer from "../../components/Footer.astro";
import Trace from "../../components/Trace.astro";
import { Code } from "astro:components";

const base = import.meta.env.BASE_URL;

const rulesFile = `require backup before delete
block rm`;

const toolDefs = `import { tool } from "ai";
import { z } from "zod";

const myTools = {
  listFiles: tool({
    description: "List files in a directory",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => {
      // your implementation here
      return { files: ["temp.log", "old-backup.tar.gz", "important.txt", "config.json"] };
    },
  }),
  readFile: tool({
    description: "Read a file's contents",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => {
      return { content: \`Contents of \${path}\` };
    },
  }),
  backup: tool({
    description: "Create a backup of a file before modifying it",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => {
      // cp file to file.bak
      return { backedUp: \`\${path}.bak\` };
    },
  }),
  delete: tool({
    description: "Delete a file (requires backup first)",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => {
      return { deleted: path };
    },
  }),
  rm: tool({
    description: "Remove a file with force",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => {
      return { removed: path };
    },
  }),
};`;

const fullExample = `import { loadRules } from "@petriflow/rules";
import { createPetriflowGate } from "@petriflow/vercel-ai";
import { generateText, tool, stepCountIs } from "ai";
import { openai } from "@ai-sdk/openai";
import { z } from "zod";

// 1. Load and verify rules
const { nets, verification } = await loadRules("./safety.rules");
console.log(verification);
// [
//   { name: "require-backup-before-delete", reachableStates: 3 },
//   { name: "block-rm",                     reachableStates: 2 },
// ]

// 2. Create the gate
const gate = createPetriflowGate(nets);

// 3. Define and wrap tools
const tools = gate.wrapTools({
  listFiles: tool({
    description: "List files in a directory",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => ({
      files: ["temp.log", "old-backup.tar.gz", "important.txt", "config.json"],
    }),
  }),
  readFile: tool({
    description: "Read a file's contents",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => ({ content: \`Contents of \${path}\` }),
  }),
  backup: tool({
    description: "Create a backup of a file before modifying it",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => ({ backedUp: \`\${path}.bak\` }),
  }),
  delete: tool({
    description: "Delete a file (requires backup first)",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => ({ deleted: path }),
  }),
  rm: tool({
    description: "Remove a file with force",
    inputSchema: z.object({ path: z.string() }),
    execute: async ({ path }) => ({ removed: path }),
  }),
});

// 4. Run the agent
const { text } = await generateText({
  model: openai("gpt-4o"),
  tools,
  system: gate.systemPrompt(),
  stopWhen: stepCountIs(10),
  prompt: "Clean up /tmp/project: list the files, delete temp.log, and rm old-backup.tar.gz",
});`;

const installCmd = `bun add @petriflow/vercel-ai @petriflow/rules ai @ai-sdk/openai zod`;
---
<Layout title="Tutorial: File Safety Agent | PetriFlow" description="Build a file management agent with sequencing and blocking rules. Learn deferred transitions and free tools.">
  <Nav currentPage="docs" />

  <div class="doc-wrapper">
    <div class="page-header">
      <nav class="doc-breadcrumb" aria-label="Documentation navigation">
        <a href={`${base}docs/`}>Docs</a>
        <span aria-hidden="true">/</span>
        <span>Tutorial: File Safety</span>
        <span class="doc-breadcrumb-sep" aria-hidden="true"></span>
        <a href={`${base}docs/tutorial-deployment/`}>Next: Deployment &rarr;</a>
      </nav>
      <h1>Tutorial: File Safety Agent</h1>
      <p>Build a file management agent that <strong>must</strong> back up before deleting and <strong>can never</strong> use <code>rm</code>. You'll learn sequencing rules, permanent blocks, deferred transitions, and free tools.</p>
    </div>

    <aside class="doc-sidebar" aria-label="Page navigation">
      <nav class="doc-nav">
        <a href="#what-youll-build">What you'll build</a>
        <a href="#prerequisites">Prerequisites</a>
        <a href="#write-the-rules">Write the rules</a>
        <a href="#define-the-tools">Define the tools</a>
        <a href="#wire-it-up">Wire it up</a>
        <a href="#see-it-in-action">See it in action</a>
        <a href="#what-you-learned">What you learned</a>
        <a href="#next-steps">Next steps</a>
      </nav>
    </aside>

    <main id="main-content">

    <div class="doc-section" id="what-youll-build">
      <h2>What you'll build</h2>
      <p>A file management agent with 5 tools: <code>listFiles</code>, <code>readFile</code>, <code>backup</code>, <code>delete</code>, and <code>rm</code>. Two rules control the agent's behavior: <code>backup</code> must succeed before <code>delete</code> is allowed, and <code>rm</code> is permanently blocked. The other tools are free — no rules mention them, so they always work.</p>
      <p><strong>Concepts covered:</strong> sequencing (<code>require ... before ...</code>), permanent blocking (<code>block</code>), deferred transitions, free tools.</p>
    </div>

    <div class="doc-section" id="prerequisites">
      <h2>Prerequisites</h2>
      <Code code={installCmd} lang="bash" />
      <p>You'll also need an API key for your model provider (e.g. <code>OPENAI_API_KEY</code>).</p>
    </div>

    <div class="doc-section" id="write-the-rules">
      <h2>Write the rules</h2>
      <p>Create a file called <code>safety.rules</code>:</p>
      <div class="example-rule" set:html={`<span class="comment"># safety.rules</span>
<span class="kw">require</span> <span class="str">backup</span> before <span class="str">delete</span>
<span class="kw">block</span> <span class="str">rm</span>`} />

      <p>Two rules, two different mechanisms:</p>
      <ul>
        <li><strong style="color:var(--text-secondary)">require backup before delete</strong> — compiles to a Petri net where <code>delete</code> is only reachable after <code>backup</code> succeeds. The transition is <em>deferred</em>: the net only advances when the tool's <code>execute</code> completes without error. If backup fails, delete stays locked.</li>
        <li><strong style="color:var(--text-secondary)">block rm</strong> — compiles to a net where the <code>rm</code> transition is provably dead in all reachable states. No sequence of tool calls can ever unlock it.</li>
      </ul>
      <p>Tools not mentioned in any rule (<code>listFiles</code>, <code>readFile</code>) are <strong>free tools</strong> — they pass through the gate without checks.</p>
    </div>

    <div class="doc-section" id="define-the-tools">
      <h2>Define the tools</h2>
      <p>Define your tools using the Vercel AI SDK's <code>tool()</code> function. These are standard tool definitions — PetriFlow doesn't change how you write them.</p>
      <Code code={toolDefs} lang="typescript" />
      <p>Each tool has a <code>description</code> (for the model), a <code>parameters</code> schema (validated by the SDK), and an <code>execute</code> function (your implementation). PetriFlow wraps <code>execute</code> with gate checks — the tool definitions themselves stay the same.</p>
    </div>

    <div class="doc-section" id="wire-it-up">
      <h2>Wire it up</h2>
      <p>Load the rules, create a gate, wrap your tools, and pass everything to <code>generateText</code>. Three imports, four steps.</p>
      <Code code={fullExample} lang="typescript" />
      <p><code>loadRules</code> reads the <code>.rules</code> file and compiles each rule into a verified Petri net. <code>createPetriflowGate</code> wraps them into a gate. <code>wrapTools</code> instruments every tool's <code>execute</code> method with gate checks. <code>systemPrompt()</code> tells the model which tools are gated and why.</p>
    </div>

    <div class="doc-section" id="see-it-in-action">
      <h2>See it in action</h2>
      <p>Here's what happens when the agent tries to clean up a directory:</p>

      <Trace label="// agent cleans up /tmp/project" steps={[
        { icon: "ok", html: `Agent calls <strong>listFiles({ path: "/tmp/project" })</strong><br><span class="ok-text">OK</span> free tool — no rules mention listFiles` },
        { icon: "blocked", html: `Agent calls <strong>delete({ path: "temp.log" })</strong><br><span class="blocked-text">BLOCKED</span> backup required first` },
        { icon: "ok", html: `Agent calls <strong>backup({ path: "temp.log" })</strong><br><span class="ok-text">OK</span> deferred — net advances after execute succeeds` },
        { icon: "ok", html: `Agent calls <strong>delete({ path: "temp.log" })</strong><br><span class="ok-text">ALLOWED</span> backup succeeded, delete is now unlocked` },
        { icon: "blocked", html: `Agent calls <strong>rm({ path: "old-backup.tar.gz" })</strong><br><span class="blocked-text">BLOCKED</span> permanently blocked — transition provably dead` },
        { icon: "ok", html: `Agent explains it cannot use <strong>rm</strong> and suggests using <strong>backup</strong> then <strong>delete</strong> instead` },
      ]} />

      <p>Key observations:</p>
      <ul>
        <li><code>listFiles</code> works immediately — it's a free tool, not mentioned in any rule.</li>
        <li><code>delete</code> is blocked until <code>backup</code> <em>succeeds</em>. If backup threw an error, delete would stay locked.</li>
        <li><code>rm</code> is permanently blocked. The model sees the block reason in the error and adjusts its plan.</li>
        <li>The backup/delete cycle is repeatable — after deleting, you need to backup again before the next delete.</li>
      </ul>
    </div>

    <div class="doc-section" id="what-you-learned">
      <h2>What you learned</h2>
      <ul>
        <li><strong style="color:var(--text-secondary)">require A before B</strong> — enforces ordering via a Petri net. B is structurally unreachable without A.</li>
        <li><strong style="color:var(--text-secondary)">block X</strong> — makes a tool permanently unreachable in all states.</li>
        <li><strong style="color:var(--text-secondary)">Deferred transitions</strong> — the net only advances when the tool's execute succeeds. Failures don't unlock gated tools.</li>
        <li><strong style="color:var(--text-secondary)">Free tools</strong> — tools not mentioned in any rule pass through the gate without checks.</li>
        <li><strong style="color:var(--text-secondary)">The wiring pattern</strong> — <code>loadRules</code> &rarr; <code>createPetriflowGate</code> &rarr; <code>wrapTools</code> &rarr; <code>generateText</code>.</li>
      </ul>
    </div>

    <div class="doc-section" id="next-steps">
      <h2>Next steps</h2>
      <ul>
        <li><a href={`${base}docs/tutorial-deployment/`} style="color:var(--accent-text)">Tutorial 2: Deployment Agent</a> — chained dependencies, human approval gates, and rate limits.</li>
        <li><a href={`${base}docs/rules/`} style="color:var(--accent-text)">Rules Engine reference</a> — full DSL syntax and composition model.</li>
        <li><a href={`${base}docs/vercel-ai/`} style="color:var(--accent-text)">Vercel AI SDK docs</a> — shadow mode, registry mode, error handling.</li>
      </ul>
    </div>

    </main>
  </div>

  <Footer variant="minimal" />
</Layout>
