---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
import Footer from "../components/Footer.astro";
import Logo from "../components/Logo.astro";
import Trace from "../components/Trace.astro";
import InstallBar from "../components/InstallBar.astro";
import IntegrationCard from "../components/IntegrationCard.astro";
import Icon from "../components/Icon.astro";
import { Code } from "astro:components";
---
<Layout title="PetriFlow - Provably Safe AI Agents">
  <Nav currentPage="index" />

  <!-- HERO -->
  <main id="main-content">
  <section class="hero">
    <div class="container">
      <h1>Provably Safe<br /><span class="hero-accent">AI Agents.</span></h1>
      <p class="hero-sub">
        AI agents decide which tools to call: shell commands, APIs, databases.
        <strong style="color:var(--text)">Petri<span style="color:var(--accent-text)">Flow</span></strong> intercepts every call and enforces rules they <strong style="color:var(--text)">cannot</strong> break.
      </p>
      <div class="hero-buttons">
        <a href="#how-it-works" class="btn btn-primary">See How It Works</a>
        <a href="https://github.com/joshuaisaact/petri-flow" class="btn btn-secondary"><Icon name="github" size={16} />Star on GitHub</a>
      </div>

      <InstallBar />

      <div class="hero-code">
        <div class="hero-code-window">
          <div class="hero-code-titlebar" aria-hidden="true">
            <div class="hero-code-dot"></div>
            <div class="hero-code-dot"></div>
            <div class="hero-code-dot"></div>
            <span>safety.rules</span>
          </div>
          <pre class="hero-code-body"><code><span class="kw">require</span> <span class="str">lint</span> before <span class="str">test</span>
<span class="kw">require</span> <span class="str">test</span> before <span class="str">deploy</span>
<span class="kw">require</span> <span class="str">human-approval</span> before <span class="str">deploy</span>
<span class="kw">limit</span> <span class="str">deploy</span> to <span class="str">2</span> per <span class="str">session</span>
<span class="comment"><!-- --># that's it. each rule is mathematically verified.</span></code></pre>
        </div>
        <p class="hero-code-caption">
          4 rules, 1 domain. <strong>Every reachable state checked.</strong> Zero bypasses possible.
        </p>
      </div>
    </div>
  </section>

  <!-- PROBLEM -->
  <section class="problem" id="problem" data-animate aria-labelledby="problem-heading">
    <div class="container">
      <h2 id="problem-heading" class="section-title">AI agents call tools.<br />Nothing controls the order.</h2>
      <p class="section-sub">
        An AI agent works by calling tools: functions that send messages, run shell commands,
        query databases, deploy code. The model picks which tools to call and in what order.
        There is no runtime layer between the model&rsquo;s decision and the tool executing.
      </p>

      <blockquote>
        "Most failures are not fancy exploits. Someone messaged the bot, and the bot did what they asked."
        <cite>- OpenClaw safety documentation</cite>
      </blockquote>

      <div class="problem-grid">
        <div class="problem-card">
          <h3>Prompts don&rsquo;t enforce</h3>
          <p>You can write &ldquo;always back up before deleting&rdquo; in your system prompt. The model reads it. The model might follow it. Instructions are <strong style="color:var(--red)">suggestions</strong>, not constraints.</p>
        </div>
        <div class="problem-card">
          <h3>Deny-lists are never complete</h3>
          <p>You block <code>rm -rf</code> but miss <code>find -delete</code>. You block <code>DROP TABLE</code> but miss <code>TRUNCATE</code>. The agent finds <strong style="color:var(--red)">the gap you didn&rsquo;t think of</strong>.</p>
        </div>
        <div class="problem-card">
          <h3>IAM controls who, not when</h3>
          <p>Identity management controls which users can call a tool. It doesn&rsquo;t control the <strong style="color:var(--red)">order</strong>. &ldquo;This agent can run bash&rdquo; doesn&rsquo;t prevent it deleting without backing up first.</p>
        </div>
        <div class="problem-card">
          <h3>More tools, more risk</h3>
          <p>Every tool you hand an agent is a tool it can misuse. You&rsquo;re <strong style="color:var(--red)">scaling capability and risk together</strong>, with nothing constraining the interaction between tools.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- SOLUTION -->
  <section class="solution" id="solution" data-animate aria-labelledby="solution-heading">
    <div class="container">
      <h2 id="solution-heading" class="section-title">Your instructions are prompts.<br />Make them enforceable.</h2>
      <p class="section-sub">
        Tools make your agent powerful. Rules make it <strong style="color:var(--accent-text)">safe</strong>.
      </p>

      <div class="solution-compare">
        <div class="solution-panel bad">
          <div class="solution-panel-label">Skill alone</div>
          <div class="code-block" set:html={`<span class="comment"># ---</span>
<span class="comment"># name: cleanup</span>
<span class="comment"># description: Delete unused files</span>
<span class="comment"># ---</span>

<span class="comment">## Important</span>
Always back up files before deleting.
Never delete without a backup.

<span class="comment">## Usage</span>
<span class="fn">1.</span> Back up the target directory
<span class="fn">2.</span> Delete unused files
<span class="fn">3.</span> Verify cleanup`} />
          <p class="panel-note">The model reads this. The model might follow it.<br /><br /><strong>Nothing <em>makes</em> it.</strong></p>
        </div>

        <div class="solution-panel good">
          <div class="solution-panel-label">Skill + <span style="color:var(--text)">Petri</span><span style="color:var(--accent-text)">Flow</span> rule</div>
          <div class="code-block" set:html={`<span class="comment"># allow only these bash commands:</span>
<span class="kw">map</span> bash.command <span class="str">cp</span> as <span class="fn">backup</span>
<span class="kw">map</span> bash.command <span class="str">rm</span> as <span class="fn">delete</span>

<span class="comment"># block everything else:</span>
<span class="kw">block</span> <span class="str">bash</span>

<span class="comment"># enforce ordering:</span>
<span class="kw">require</span> <span class="str">backup</span> before <span class="str">delete</span>`} />
          <p class="panel-note">Only mapped commands can reach the shell. <code style="font-family:var(--mono);font-size:12px">unlink</code>, <code style="font-family:var(--mono);font-size:12px">shred</code>, anything unmapped is blocked.<br /><br /><strong>Allowlist, not deny-list.</strong></p>
        </div>
      </div>
    </div>
  </section>

  <!-- REAL WORLD EXAMPLE -->
  <section class="real-world" id="example" data-animate aria-labelledby="example-heading">
    <div class="container">
      <h2 id="example-heading" class="section-title">A <span style="background:linear-gradient(135deg,#25D366,#128C7E);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text">WhatsApp</span> bot that<br />can't message the wrong person.</h2>
      <p class="section-sub">
        A real agent skill for sending WhatsApp messages via CLI.
        The skill tells the model how to send messages.
        Three rules make it safe.
      </p>

      <div class="rw-layout">
        <!-- Left: the skill -->
        <div class="rw-panel">
          <div class="rw-panel-header">
            <div class="rw-dot" aria-hidden="true"></div><div class="rw-dot" aria-hidden="true"></div><div class="rw-dot" aria-hidden="true"></div>
            SKILL.md
          </div>
          <div class="rw-panel-body" set:html={`<span class="heading"># WhatsApp CLI</span>
<span class="dim">---</span>
<span class="dim">name: whatsapp</span>
<span class="dim">description: Send WhatsApp messages</span>
<span class="dim">---</span>

<span class="heading">## Safety</span>
Require explicit recipient + message text.
Confirm recipient + message before sending.
If anything is ambiguous, ask first.

<span class="heading">## Send</span>
<span class="fn">wacli send text</span> --to <span class="str">"+1415..."</span> --message <span class="str">"..."</span>
<span class="fn">wacli send file</span> --to <span class="str">"+1415..."</span> --file <span class="str">/path</span>

<span class="comment"># the model reads these instructions.</span>
<span class="comment"># nothing enforces them.</span>`} />
        </div>

        <!-- Right: the rules -->
        <div class="rw-panel">
          <div class="rw-panel-header">
            <div class="rw-dot" aria-hidden="true"></div><div class="rw-dot" aria-hidden="true"></div><div class="rw-dot" aria-hidden="true"></div>
            <span><span style="color:#25D366">whatsapp</span>.rules</span>
          </div>
          <div class="rw-panel-body" set:html={`<span class="comment"># look up the recipient first.</span>
<span class="comment"># no guessing phone numbers from memory.</span>
<span class="kw">require</span>  <span class="str">whatsapp.lookup</span>  before  <span class="str">whatsapp.send</span>

<span class="comment"># human confirms recipient + message.</span>
<span class="comment"># manual gate. no auto-bypass possible.</span>
<span class="kw">require</span>  <span class="str">human-approval</span>  before  <span class="str">whatsapp.send</span>

<span class="comment"># one send per lookup cycle.</span>
<span class="comment"># no batch-firing after a single lookup.</span>
<span class="kw">limit</span>    <span class="str">whatsapp.send</span>  to  <span class="str">1</span>  per  <span class="str">whatsapp.lookup</span>`} />
        </div>
      </div>

      <Trace label="// what happens when the agent tries to send a message" steps={[
        { icon: "blocked", html: `Agent calls <strong>whatsapp { action: "send", to: "+1415...", message: "Hey!" }</strong><br><span class="blocked-text">BLOCKED</span> no recipient lookup yet` },
        { icon: "ok", html: `Agent calls <strong>whatsapp { action: "lookup", query: "Sarah" }</strong><br><span class="ok-text">OK</span> resolves to +14155551212` },
        { icon: "blocked", html: `Agent tries <strong>whatsapp { action: "send" }</strong> again<br><span class="blocked-text">BLOCKED</span> human hasn't approved yet` },
        { icon: "wait", html: `PetriFlow prompts: <strong>"Send 'Hey!' to Sarah (+14155551212)?"</strong><br>Human approves &rarr; manual gate opens` },
        { icon: "ok", html: `Agent calls <strong>whatsapp { action: "send", to: "+14155551212", message: "Hey!" }</strong><br><span class="ok-text">ALLOWED</span> lookup done, human approved, token consumed` },
        { icon: "blocked", html: `Agent tries to send another message<br><span class="blocked-text">BLOCKED</span> budget consumed, must look up again` },
      ]} />
    </div>
  </section>

  <!-- COMPARISON TABLE -->
  <section class="comparison" id="comparison" data-animate aria-labelledby="comparison-heading">
    <div class="container">
      <h2 id="comparison-heading" class="section-title">Policy checks vs safety rules.</h2>
      <p class="section-sub">
        Four scenarios. Same requirements. Two fundamentally different approaches.
      </p>

      <div class="table-wrapper">
        <table class="comparison-table">
          <caption class="sr-only">Comparison of policy checks vs PetriFlow safety rules across four scenarios</caption>
          <thead>
            <tr>
              <th>Scenario</th>
              <th>Policy checks</th>
              <th><span style="color:var(--text)">Petri</span><span style="color:var(--accent-text)">Flow</span> rules</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Tool approval</td>
              <td>
                <code><span class="kw">if</span> (!approved) <span class="fn">deny</span>()</code><br />
                <span class="tag-no">Bypassable</span> check can be skipped, token can expire between check and use
              </td>
              <td>
                <code><span class="kw">require</span> <span class="str">human-approval</span> before <span class="str">shell</span></code><br />
                <span class="tag-yes">Proven safe</span> no code path reaches shell without approval token
              </td>
            </tr>
            <tr>
              <td>Message gating</td>
              <td>
                <code><span class="kw">if</span> (!allowlist.<span class="fn">has</span>(channel)) <span class="fn">deny</span>()</code><br />
                <span class="tag-no">Bypassable</span> allowlist stale, new channel added without check
              </td>
              <td>
                <code><span class="kw">require</span> <span class="str">read-channel</span> before <span class="str">send</span></code><br />
                <span class="tag-yes">Proven safe</span> send is structurally unreachable without prior read
              </td>
            </tr>
            <tr>
              <td>Privilege escalation</td>
              <td>
                <code><span class="kw">if</span> (BLOCKED.<span class="fn">includes</span>(tool)) <span class="fn">deny</span>()</code><br />
                <span class="tag-no">Bypassable</span> list incomplete, agent finds unlisted equivalent
              </td>
              <td>
                <code><span class="kw">block</span> <span class="str">privilege-escalation</span></code><br />
                <span class="tag-yes">Proven safe</span> transition provably dead in all reachable states
              </td>
            </tr>
            <tr>
              <td>Sandbox escape</td>
              <td>
                <code><span class="kw">if</span> (!<span class="fn">inSandbox</span>()) <span class="fn">deny</span>()</code><br />
                <span class="tag-no">Bypassable</span> misconfigured mount, container escape, race condition
              </td>
              <td>
                <code><span class="kw">require</span> <span class="str">human-approval</span> before <span class="str">host-access</span></code><br />
                <span class="tag-yes">Proven safe</span> only a manual gate can unlock host access
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- HOW IT WORKS (3 layers) -->
  <section class="how-it-works" id="how-it-works" data-animate aria-labelledby="how-it-works-heading">
    <div class="container">
      <h2 id="how-it-works-heading" class="section-title">Simple by default.<br />Powerful when you need it.</h2>
      <p class="section-sub">
        Three layers. Most users never leave the first.
      </p>

      <div class="layers">
        <!-- Layer 1: Presets -->
        <div class="layer">
          <div class="layer-header">
            <div class="layer-number">1</div>
            <div class="layer-title">Pick a preset</div>
          </div>
          <div class="layer-body">
            <div class="layer-desc">
              <strong>Zero configuration.</strong> Built-in safety patterns for the most common agent risks.
              Pick a preset, pick your framework adaptor, done. Each preset is already mathematically verified.
            </div>
            <Code code={`import { backupBeforeDelete,
  createGateManager } from "@petriflow/rules"

const manager = createGateManager(
  [backupBeforeDelete()],
  { mode: "enforce" }
)`} lang="ts" theme="github-dark" />
          </div>
        </div>

        <!-- Layer 2: Declarative rules -->
        <div class="layer">
          <div class="layer-header">
            <div class="layer-number">2</div>
            <div class="layer-title">Write declarative rules</div>
          </div>
          <div class="layer-body">
            <div class="layer-desc">
              <strong>Custom constraints, simple syntax.</strong> Define your own safety rules
              with a small declarative language. PetriFlow compiles them into verifiable
              structures and checks every reachable state before your agent runs.
            </div>
            <pre class="layer-code"><span class="kw">require</span> <span class="str">read-channel</span> before <span class="str">send-message</span>
<span class="kw">require</span> <span class="str">human-approval</span> before <span class="str">deploy-prod</span>

<span class="kw">limit</span>  <span class="str">discord.sendMessage</span> to <span class="str">5</span> per session
<span class="kw">block</span>  <span class="str">discord.timeout</span> <span class="comment"># provably dead</span></pre>
          </div>
        </div>

        <!-- Layer 3: Raw definitions -->
        <div class="layer">
          <div class="layer-header">
            <div class="layer-number">3</div>
            <div class="layer-title">Full control</div>
          </div>
          <div class="layer-body">
            <div class="layer-desc">
              <strong>Custom state machines with formal verification.</strong> Define places, transitions,
              tool mappings, and semantic validators. Design any safety topology you need.
              The same exhaustive verification runs on your custom definitions.
            </div>
            <Code code={`defineSkillNet({
  places: ["ready", "backedUp"],
  transitions: [
    { name: "backup",
      inputs: ["ready"],
      outputs: ["backedUp"],
      tools: ["backup"],
      deferred: true },
    { name: "destroy",
      inputs: ["backedUp"],
      outputs: ["ready"],
      tools: ["destructive"] },
  ]
})`} lang="ts" theme="github-dark" />
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- TUTORIALS -->
  <section class="tutorials" id="tutorials" data-animate aria-labelledby="tutorials-heading">
    <div class="container">
      <h2 id="tutorials-heading" class="section-title">Build something real.<br />Learn by doing.</h2>
      <p class="section-sub">
        Three step-by-step tutorials. Each builds a working agent with increasing complexity.
      </p>

      <div class="tutorials-grid">
        <a href={`${import.meta.env.BASE_URL}docs/tutorial-file-safety/`} class="tutorial-card">
          <div class="tutorial-number">1</div>
          <h3>File Safety Agent</h3>
          <p>Sequencing + permanent blocking. The agent must back up before deleting and can never use <code>rm</code>.</p>
          <span class="tutorial-link">Build it &rarr;</span>
        </a>

        <a href={`${import.meta.env.BASE_URL}docs/tutorial-deployment/`} class="tutorial-card">
          <div class="tutorial-number">2</div>
          <h3>Deployment Agent</h3>
          <p>Chained dependencies + human approval + rate limits. A full CI/CD pipeline the agent cannot skip.</p>
          <span class="tutorial-link">Build it &rarr;</span>
        </a>

        <a href={`${import.meta.env.BASE_URL}docs/tutorial-discord-bot/`} class="tutorial-card">
          <div class="tutorial-number">3</div>
          <h3>Discord Bot</h3>
          <p>Dot notation tool mapping + rate limits. One tool, multiple actions, each gated independently.</p>
          <span class="tutorial-link">Build it &rarr;</span>
        </a>
      </div>
    </div>
  </section>

  <!-- SAFETY RULES SHOWCASE -->
  <section class="rules" id="rules" data-animate aria-labelledby="rules-heading">
    <div class="container">
      <h2 id="rules-heading" class="section-title">Rules you can build.<br />Guarantees you can prove.</h2>
      <p class="section-sub">
        Examples of safety patterns PetriFlow can enforce. Each is verified exhaustively before your agent starts.
      </p>

      <div class="rules-grid">
        <a href={`${import.meta.env.BASE_URL}examples/#read-before-send`} class="rule-card">
          <div class="rule-name">read-before-send</div>
          <h3>Don't message blindly</h3>
          <p>Read messages before you can send. Each read earns one send. Cycling dependency prevents spam.</p>
          <div class="rule-preview"><span class="kw">require</span> <span class="str">discord.readMessages</span> before <span class="str">discord.sendMessage</span></div>
        </a>

        <a href={`${import.meta.env.BASE_URL}examples/#test-before-deploy`} class="rule-card">
          <div class="rule-name">test-before-deploy</div>
          <h3>Don't ship broken code</h3>
          <p>Lint gates test. Test gates deploy. Deploy requires a human and is rate-limited.</p>
          <div class="rule-preview"><span class="kw">require</span> <span class="str">test</span> before <span class="str">deploy</span></div>
        </a>

        <a href={`${import.meta.env.BASE_URL}examples/#research-before-share`} class="rule-card">
          <div class="rule-name">research-before-share</div>
          <h3>Don't share fabrications</h3>
          <p>Each fetch earns one share. Each share consumes one. No sources fetched, no sharing possible.</p>
          <div class="rule-preview"><span class="kw">limit</span> <span class="str">share</span> to <span class="str">1</span> per <span class="str">fetch</span></div>
        </a>

        <a href={`${import.meta.env.BASE_URL}examples/#backup-before-delete`} class="rule-card">
          <div class="rule-name">backup-before-delete</div>
          <h3>Don't destroy without a safety net</h3>
          <p>Destructive commands blocked until a backup covers the target path. The backup must actually succeed.</p>
          <div class="rule-preview"><span class="kw">require</span> <span class="str">backup</span> before <span class="str">delete</span></div>
        </a>
      </div>
    </div>
  </section>

  <!-- INTEGRATIONS -->
  <section class="integrations" id="integrations" data-animate aria-labelledby="integrations-heading">
    <div class="container">
      <h2 id="integrations-heading" class="section-title">One safety layer.<br />Any agent framework.</h2>
      <p class="section-sub">
        PetriFlow is a standalone gate that sits between your agent and its tools.
        In-memory state machine checks, no network calls, sub-millisecond overhead.
        Thin adaptors connect it to whatever framework you already use.
      </p>

      <div class="integrations-grid">
        <IntegrationCard title="Claude Code" description="Hook into Claude Code's tool pipeline. Gate bash, file operations, and MCP tools.">
          <svg slot="logo" aria-hidden="true" width="28" height="28" viewBox="0 0 16 16" fill="#D97757"><path d="m3.127 10.604 3.135-1.76.053-.153-.053-.085H6.11l-.525-.032-1.791-.048-1.554-.065-1.505-.08-.38-.081L0 7.832l.036-.234.32-.214.455.04 1.009.069 1.513.105 1.097.064 1.626.17h.259l.036-.105-.089-.065-.068-.064-1.566-1.062-1.695-1.121-.887-.646-.48-.327-.243-.306-.104-.67.435-.48.585.04.15.04.593.456 1.267.981 1.654 1.218.242.202.097-.068.012-.049-.109-.181-.9-1.626-.96-1.655-.428-.686-.113-.411a2 2 0 0 1-.068-.484l.496-.674L4.446 0l.662.089.279.242.411.94.666 1.48 1.033 2.014.302.597.162.553.06.17h.105v-.097l.085-1.134.157-1.392.154-1.792.052-.504.25-.605.497-.327.387.186.319.456-.045.294-.19 1.23-.37 1.93-.243 1.29h.142l.161-.16.654-.868 1.097-1.372.484-.545.565-.601.363-.287h.686l.505.751-.226.775-.707.895-.585.759-.839 1.13-.524.904.048.072.125-.012 1.897-.403 1.024-.186 1.223-.21.553.258.06.263-.218.536-1.307.323-1.533.307-2.284.54-.028.02.032.04 1.029.098.44.024h1.077l2.005.15.525.346.315.424-.053.323-.807.411-3.631-.863-.872-.218h-.12v.073l.726.71 1.331 1.202 1.667 1.55.084.383-.214.302-.226-.032-1.464-1.101-.565-.497-1.28-1.077h-.084v.113l.295.432 1.557 2.34.08.718-.112.234-.404.141-.444-.08-.911-1.28-.94-1.44-.759-1.291-.093.053-.448 4.821-.21.246-.484.186-.403-.307-.214-.496.214-.98.258-1.28.21-1.016.19-1.263.112-.42-.008-.028-.092.012-.953 1.307-1.448 1.957-1.146 1.227-.274.109-.477-.247.045-.44.266-.39 1.586-2.018.956-1.25.617-.723-.004-.105h-.036l-4.212 2.736-.75.096-.324-.302.04-.496.154-.162 1.267-.871z"/></svg>
          <Code code={`import { configure } from "@petriflow/claude-code"

const config = configure(".")

// merge into .claude/settings.json
// hooks: SessionStart, PreToolUse,
//   PostToolUse, PostToolUseFailure`} lang="ts" theme="github-dark" />
        </IntegrationCard>

        <IntegrationCard title="Vercel AI SDK" description="Wrap tool definitions with gate logic. Works with generateText, streamText, and any model provider.">
          <svg slot="logo" aria-hidden="true" width="28" height="28" viewBox="0 0 76 65" fill="white"><path d="M37.5274 0L75.0548 65H0L37.5274 0Z"/></svg>
          <Code code={`import { createPetriflowGate } from "@petriflow/vercel-ai"

const gate = createPetriflowGate([safetyNet])

await generateText({
  tools: gate.wrapTools({ bash, write }),
  system: gate.systemPrompt(),
})`} lang="ts" theme="github-dark" />
        </IntegrationCard>

        <IntegrationCard title="OpenClaw" description="Replace policy checks with structural rules. Drop-in safety upgrade for OpenClaw agents.">
          <svg slot="logo" aria-hidden="true" width="28" height="28" viewBox="0 0 120 120" fill="none"><defs><linearGradient id="lg" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#ff4d4d"/><stop offset="100%" stop-color="#991b1b"/></linearGradient></defs><path d="M60 10C30 10 15 35 15 55C15 75 30 95 45 100L45 110 55 110 55 100C55 100 60 102 65 100L65 110 75 110 75 100C90 95 105 75 105 55C105 35 90 10 60 10Z" fill="url(#lg)"/><path d="M20 45C5 40 0 50 5 60C10 70 20 65 25 55C28 48 25 45 20 45Z" fill="url(#lg)"/><path d="M100 45C115 40 120 50 115 60C110 70 100 65 95 55C92 48 95 45 100 45Z" fill="url(#lg)"/><path d="M45 15Q35 5 30 8" stroke="#ff4d4d" stroke-width="3" stroke-linecap="round"/><path d="M75 15Q85 5 90 8" stroke="#ff4d4d" stroke-width="3" stroke-linecap="round"/><circle cx="45" cy="35" r="6" fill="#050810"/><circle cx="75" cy="35" r="6" fill="#050810"/><circle cx="46" cy="34" r="2.5" fill="#00e5cc"/><circle cx="76" cy="34" r="2.5" fill="#00e5cc"/></svg>
          <Code code={`import { createPetriGatePlugin }
  from "@petriflow/openclaw"

// drop-in plugin for OpenClaw agents
const plugin = createPetriGatePlugin(
  [observeBeforeSend()],
  { mode: "enforce" }
)`} lang="ts" theme="github-dark" />
        </IntegrationCard>

        <IntegrationCard title="pi-mono" description="Native extension for pi-mono. Full access to skill nets and tool mapping.">
          <span slot="logo">&pi;</span>
          <Code code={`import { composeGates }
  from "@petriflow/pi-extension"

// native extension with full net access
const gates = composeGates(
  [testBeforeDeploy()],
  { mode: "enforce" }
)`} lang="ts" theme="github-dark" />
        </IntegrationCard>
      </div>
    </div>
  </section>

  <!-- UNDER THE HOOD -->
  <section class="under-hood" id="under-hood" data-animate aria-labelledby="under-hood-heading">
    <div class="container">
      <h2 id="under-hood-heading" class="section-title">A type system<br />for agent tools.</h2>

      <div class="under-hood-content">
        <div class="under-hood-text">
          <p>
            TypeScript catches <code style="font-family:var(--mono);font-size:0.85em">undefined is not a function</code> before your code runs.
            PetriFlow catches <strong style="color:var(--accent-text)">"agent deleted without backing up"</strong> before your agent runs.
            Same idea: compile-time proof, not runtime hope.
          </p>
          <p>
            Every rule compiles to a state machine. Every reachable state is enumerated.
            If the verifier says "safe," it means safe in <strong style="color:var(--accent-text)">every possible execution</strong>,
            not just the ones you tested.
          </p>

          <div class="under-hood-stats">
            <div class="under-hood-stat">
              <div class="under-hood-stat-value">196</div>
              <div class="under-hood-stat-label">Reachable states verified</div>
            </div>
            <div class="under-hood-stat">
              <div class="under-hood-stat-value">4/4</div>
              <div class="under-hood-stat-label">Terminal states valid</div>
            </div>
            <div class="under-hood-stat">
              <div class="under-hood-stat-value">0</div>
              <div class="under-hood-stat-label">Bypassable checks</div>
            </div>
          </div>

        </div>

        <div class="under-hood-visual">
          <div class="label">$ petriflow verify</div>
          <div class="verify-output">
            <span class="fn">Verifying</span> backup-before-delete<br />
            <span class="dim">&nbsp;&nbsp;</span>states: <span class="str">196</span> &middot; terminal: <span class="str">4</span> &middot; deadlocks: <span class="str">0</span><br />
            <br />
            <span class="dim">&nbsp;&nbsp;</span><span class="kw">invariant</span> "no unguarded delete"<br />
            <span class="dim">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="pass">PASS</span> holds in all reachable states<br />
            <br />
            <span class="dim">&nbsp;&nbsp;</span><span class="kw">invariant</span> "privilege escalation impossible"<br />
            <span class="dim">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="pass">PASS</span> transition provably dead<br />
            <br />
            <span class="dim">&nbsp;&nbsp;</span><span class="kw">invariant</span> "human gate required for prod"<br />
            <span class="dim">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="pass">PASS</span> no auto path exists<br />
            <br />
            <span class="pass">All invariants verified.</span><br />
            <span style="color:var(--accent-text);font-weight:600">0 violations across 196 states.</span>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- BENCHMARKS -->
  <section class="benchmarks" id="benchmarks" data-animate aria-labelledby="benchmarks-heading">
    <div class="container">
      <h2 id="benchmarks-heading" class="section-title">Deep dives.</h2>
      <p class="section-sub">
        The theory, the benchmarks, and why this approach works.
      </p>

      <a href="https://joshtuddenham.dev/blog/petri-nets/" class="benchmark-card">
        <h3>You're already building Petri nets. You're just building them badly.</h3>
        <p>The 1962 formalism behind PetriFlow. 30 lines of TypeScript, three worked examples, and proofs you can run yourself.</p>
      </a>

      <a href="https://joshtuddenham.dev/blog/agent-safety/" class="benchmark-card">
        <h3>Why AI agents need more than prompts</h3>
        <p>The problem with prompt-based safety, and how Petri nets solve it.</p>
      </a>

      <a href="https://github.com/joshuaisaact/petri-flow/blob/main/BENCHMARK.md" class="benchmark-card">
        <h3>PetriFlow vs n8n vs ReAct</h3>
        <p>An LLM agent with 3 tools modeled three ways. Same call efficiency. Only one proves termination, human gates, join semantics, and bounded iterations.</p>
        <div class="benchmark-stats">
          <span><strong style="color:var(--green)">196</strong> states verified</span>
          <span><strong style="color:var(--green)">4/4</strong> safety proofs</span>
          <span><strong style="color:var(--green)">81.8%</strong> fewer LLM calls vs ReAct</span>
        </div>
      </a>
    </div>
  </section>
  </main>

  <Footer variant="full" />

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(e => { if (e.isIntersecting) { e.target.classList.add('visible'); observer.unobserve(e.target); } });
      }, { threshold: 0.1 });
      document.querySelectorAll('[data-animate]').forEach(el => observer.observe(el));
    });
  </script>
</Layout>
