---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
import Footer from "../components/Footer.astro";
import Trace from "../components/Trace.astro";
import InstallBar from "../components/InstallBar.astro";
---
<Layout title="Examples — PetriFlow">
  <Nav currentPage="examples" />

  <div class="container-narrow">
    <div class="page-header">
      <h1>Examples</h1>
      <p>Step-by-step execution traces showing how each rule gates tool calls. Every blocked action here is <strong style="color:var(--text-secondary)">structurally impossible</strong>, not a policy check that might fail.</p>
    </div>

    <InstallBar />

    <!-- read-before-send (Discord) -->
    <div class="example border-t-0!" id="read-before-send">
      <div class="example-name">read-before-send</div>
      <h2>Don't message blindly</h2>
      <p>The agent must read messages before it can send. Each read earns one send. The sequencing rule cycles &mdash; after each send, the agent must read again.</p>

      <div class="example-rule" set:html={`<span class="kw">require</span> <span class="str">discord.readMessages</span> before <span class="str">discord.sendMessage</span>
<span class="kw">limit</span> <span class="str">discord.sendMessage</span> to <span class="str">5</span> per <span class="str">session</span>`} />

      <Trace label="// agent tries to send without reading first" steps={[
        { icon: "blocked", html: `Agent calls <strong>discord({ action: "sendMessage", channel: "#dev-general", content: "Hello!" })</strong><br><span class="blocked-text">BLOCKED</span> readMessages required first` },
        { icon: "ok", html: `Agent calls <strong>discord({ action: "readMessages", channel: "#dev-general" })</strong><br><span class="ok-text">OK</span> earns one send token` },
        { icon: "ok", html: `Agent calls <strong>discord({ action: "sendMessage", channel: "#dev-general", content: "Hello!" })</strong><br><span class="ok-text">ALLOWED</span> send token consumed. Budget: 4/5` },
        { icon: "blocked", html: `Agent tries to send another message immediately<br><span class="blocked-text">BLOCKED</span> must readMessages again (rule cycles)` },
      ]} />

      <p class="example-note"><strong>1:1 read-to-send ratio + session rate limit.</strong> The agent can't spam a channel &mdash; every send requires a fresh read, and messages are capped at 5 per session. <a href={`${import.meta.env.BASE_URL}docs/tutorial-discord-bot/`} style="color:var(--accent-text)">Full tutorial &rarr;</a></p>
    </div>

    <!-- test-before-deploy -->
    <div class="example" id="test-before-deploy">
      <div class="example-name">test-before-deploy</div>
      <h2>Don't ship broken code</h2>
      <p>Lint gates test. Test gates deploy. Deploy requires a human and is capped at 2 per session &mdash; no prompt injection can skip the pipeline or exhaust your deploys.</p>

      <div class="example-rule" set:html={`<span class="kw">require</span> <span class="str">lint</span> before <span class="str">test</span>
<span class="kw">require</span> <span class="str">test</span> before <span class="str">deploy</span>
<span class="kw">require</span> <span class="str">human-approval</span> before <span class="str">deploy</span>
<span class="kw">limit</span> <span class="str">deploy</span> to <span class="str">2</span> per <span class="str">session</span>`} />

      <Trace label="// agent tries to deploy" steps={[
        { icon: "blocked", html: `Agent calls <strong>deploy({ environment: "production" })</strong><br><span class="blocked-text">BLOCKED</span> lint hasn't run, test hasn't run, human hasn't approved` },
        { icon: "ok", html: `Agent calls <strong>lint()</strong><br><span class="ok-text">OK</span> linter passes, test unlocked` },
        { icon: "ok", html: `Agent calls <strong>test()</strong><br><span class="ok-text">OK</span> tests pass, deploy one gate away` },
        { icon: "wait", html: `PetriFlow calls <strong>confirm</strong>: "Allow 'deploy'?"<br>Human approves &rarr; manual gate opens` },
        { icon: "ok", html: `Agent calls <strong>deploy({ environment: "production" })</strong><br><span class="ok-text">ALLOWED</span> pipeline satisfied. Budget: 1/2 remaining` },
        { icon: "blocked", html: `After 2 deploys, a third attempt<br><span class="blocked-text">BLOCKED</span> rate limit reached — budget exhausted` },
      ]} />

      <p class="example-note"><strong>Deploy is a manual gate with a budget.</strong> Even if the agent is prompt-injected, deploys are structurally blocked until lint, test, and human approval are all satisfied. And the session limit prevents runaway deploys. <a href={`${import.meta.env.BASE_URL}docs/tutorial-deployment/`} style="color:var(--accent-text)">Full tutorial &rarr;</a></p>
    </div>

    <!-- research-before-share -->
    <div class="example" id="research-before-share">
      <div class="example-name">research-before-share</div>
      <h2>Don't share fabrications</h2>
      <p>Each fetch earns one share token. Each share consumes one. The agent can't broadcast "findings" it never actually fetched.</p>

      <div class="example-rule"><span class="kw">require</span> <span class="str">web-fetch</span> before <span class="str">share-result</span></div>

      <Trace label="// agent tries to share a research summary" steps={[
        { icon: "blocked", html: `Agent calls <strong>slack.sendMessage({ text: "Research summary: React 20 is out..." })</strong><br><span class="blocked-text">BLOCKED</span> no fetch has been done` },
        { icon: "ok", html: `Agent calls <strong>webFetch({ url: "https://react.dev/blog" })</strong><br><span class="ok-text">OK</span> earns one share token` },
        { icon: "ok", html: `Agent calls <strong>slack.sendMessage({ text: "React blog says..." })</strong><br><span class="ok-text">ALLOWED</span> share token consumed` },
        { icon: "blocked", html: `Agent calls <strong>slack.sendMessage({ text: "Also, Vue 5 is..." })</strong><br><span class="blocked-text">BLOCKED</span> no token left, must fetch again` },
      ]} />

      <p class="example-note"><strong>1:1 fetch-to-share ratio.</strong> The agent can't hallucinate research results and share them &mdash; every share must be backed by an actual web fetch.</p>
    </div>

    <!-- backup-before-delete -->
    <div class="example" id="backup-before-delete">
      <div class="example-name">backup-before-delete</div>
      <h2>Don't destroy without a safety net</h2>
      <p>Only mapped bash commands can reach the shell. Everything else is blocked. The backup must actually succeed before delete is unlocked (deferred check).</p>

      <div class="example-rule" set:html={`<span class="comment"># allow only these bash commands:</span>
<span class="kw">map</span> bash.command <span class="str">cp</span> as <span class="fn">backup</span>
<span class="kw">map</span> bash.command <span class="str">rm</span> as <span class="fn">delete</span>

<span class="comment"># block everything else:</span>
<span class="kw">block</span> <span class="str">bash</span>

<span class="comment"># enforce ordering:</span>
<span class="kw">require</span> <span class="str">backup</span> before <span class="str">delete</span>`} />

      <Trace label="// agent tries to clean up a data directory" steps={[
        { icon: "blocked", html: `Agent calls <strong>bash({ command: "rm -rf data/" })</strong><br><span class="blocked-text">BLOCKED</span> rm maps to delete, no backup yet` },
        { icon: "blocked", html: `Agent calls <strong>bash({ command: "unlink data/temp.log" })</strong><br><span class="blocked-text">BLOCKED</span> unlink is unmapped, caught by block bash` },
        { icon: "ok", html: `Agent calls <strong>bash({ command: "cp -r data/ /tmp/data-backup" })</strong><br><span class="ok-text">OK</span> cp maps to backup, deferred until confirmed` },
        { icon: "ok", html: `Agent calls <strong>bash({ command: "rm -rf data/" })</strong><br><span class="ok-text">ALLOWED</span> backup succeeded, delete unlocked` },
      ]} />

      <p class="example-note"><strong>Allowlist, not deny-list.</strong> <code style="font-family:var(--mono);font-size:12px">unlink</code>, <code style="font-family:var(--mono);font-size:12px">shred</code>, <code style="font-family:var(--mono);font-size:12px">find -delete</code> &mdash; anything unmapped is blocked. Only <code style="font-family:var(--mono);font-size:12px">cp</code> and <code style="font-family:var(--mono);font-size:12px">rm</code> can reach the shell, and only in the right order. <a href={`${import.meta.env.BASE_URL}docs/tutorial-file-safety/`} style="color:var(--accent-text)">Full tutorial &rarr;</a></p>
    </div>

    <!-- whatsapp (bonus) -->
    <div class="example" id="whatsapp">
      <div class="example-name">whatsapp messaging</div>
      <h2>Don't message the wrong person</h2>
      <p>Three rules compose to create a safe messaging flow: lookup before send, human approval, and rate limiting.</p>

      <div class="example-rule" set:html={`<span class="comment"># look up the recipient first</span>
<span class="kw">require</span>  <span class="str">whatsapp.lookup</span>  before  <span class="str">whatsapp.send</span>

<span class="comment"># human confirms recipient + message</span>
<span class="kw">require</span>  <span class="str">human-approval</span>  before  <span class="str">whatsapp.send</span>

<span class="comment"># one send per lookup cycle</span>
<span class="kw">limit</span>    <span class="str">whatsapp.send</span>  to  <span class="str">1</span>  per  <span class="str">whatsapp.lookup</span>`} />

      <Trace label="// agent tries to send a WhatsApp message" steps={[
        { icon: "blocked", html: `Agent calls <strong>whatsapp({ action: "send", to: "+1415...", message: "Hey!" })</strong><br><span class="blocked-text">BLOCKED</span> no recipient lookup yet` },
        { icon: "ok", html: `Agent calls <strong>whatsapp({ action: "lookup", query: "Sarah" })</strong><br><span class="ok-text">OK</span> resolves to +14155551212` },
        { icon: "blocked", html: `Agent calls <strong>whatsapp({ action: "send" })</strong><br><span class="blocked-text">BLOCKED</span> human hasn't approved yet` },
        { icon: "wait", html: `PetriFlow prompts: <strong>"Send 'Hey!' to Sarah (+14155551212)?"</strong><br>Human approves &rarr; manual gate opens` },
        { icon: "ok", html: `Agent calls <strong>whatsapp({ action: "send", to: "+14155551212", message: "Hey!" })</strong><br><span class="ok-text">ALLOWED</span> lookup done, human approved, token consumed` },
        { icon: "blocked", html: `Agent calls <strong>whatsapp({ action: "send", message: "One more thing" })</strong><br><span class="blocked-text">BLOCKED</span> budget consumed, must look up again` },
      ]} />

      <p class="example-note"><strong>Three rules compose into one safe flow.</strong> The agent can't guess phone numbers, can't send without human confirmation, and can't batch-fire messages after a single lookup.</p>
    </div>
  </div>

  <Footer variant="minimal" />
</Layout>
